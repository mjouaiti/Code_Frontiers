//
//  main.cpp
//  Graphical
//
//  Created by Melanie Jouaiti on 29/09/2017.
//  Copyright Â© 2017 Melanie Jouaiti. All rights reserved.
//



#include <iostream>
#include <math.h>

#ifdef __APPLE__
#   define _OSX
#elif defined(__linux__)
#   define _LINUX
#endif

#if defined(_LINUX)
#   include <GL/glew.h>
#endif

#define GLFW_INCLUDE_GLCOREARB
#include <GLFW/glfw3.h>

//#define VREP
// 0 for oscillator, 1 for one joint, 2 for 2 joints, 3 for whole robot, 4 for robot-robot
#define SIMULATION_TYPE 2

#include "Grapher.h"
#if SIMULATION_TYPE == 0
#include "../Simulation/SimulationOscillator.h"
#elif SIMULATION_TYPE == 1
#include "../Simulation/Simulation1.h"
#elif SIMULATION_TYPE == 2
#include "../Simulation/Approach.h"
#include "../Simulation/Simulation2.h"
#elif SIMULATION_TYPE == 3
#include "../Simulation/Simulation_Whole.h"
#else
#include "../Simulation/Simulation2-2.h"
#endif
#include "../common.h"

#include <iostream>
#include <fstream>
#include <math.h>
#include <vector>

std::vector<std::string> kuka_names = {"LBR_iiwa_14_R820_joint1", "LBR_iiwa_14_R820_joint2", "LBR_iiwa_14_R820_joint3", "LBR_iiwa_14_R820_joint4", "LBR_iiwa_14_R820_joint5", "LBR_iiwa_14_R820_joint6", "LBR_iiwa_14_R820_joint7"};
std::vector<std::string> mico_names = {"Mico_joint1", "Mico_joint2", "Mico_joint3", "Mico_joint4", "Mico_joint5", "Mico_joint6"};
std::vector<std::string> mico_names2 = {"Mico_joint1#0", "Mico_joint2#0", "Mico_joint3#0", "Mico_joint4#0", "Mico_joint5#0", "Mico_joint6#0"};

#define PI acos(-1)

GLint WIDTH = 1024, HEIGHT = 768;

#ifdef __APPLE__
int f = 2;
#else
int f = 1;
#endif

#ifdef _LINUX
std::string path = "../Graphical/";
GLint V_WIDTH = WIDTH / 2, V_HEIGHT = HEIGHT / 2;
#else
std::string logPath = "";
std::string path = "/Users/Melanie/Documents/Studies/LORIA/Handshaking/Graphical/";
GLint V_WIDTH = WIDTH, V_HEIGHT = HEIGHT;
#endif

void init();
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);
void mouse_callback(GLFWwindow* window, int button, int action, int mods);
void position_callback(GLFWwindow* window, double xpos, double ypos);
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);

float cursorPositionX, cursorPositionY;

GLFWwindow* _Window;
Grapher* grapher;

int main()
{
    //init();
    //Create Shader
    //Shader shader((path + "shaders/shader.vs").c_str(), (path + "shaders/shader.frag").c_str());
    
    //glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    //grapher = new Grapher(NB_VARIABLES);
    
#if SIMULATION_TYPE == 0
    SimulationOscillator simulation(mico_names);
#elif SIMULATION_TYPE == 1
    Simulation1 simulation(mico_names);
#elif SIMULATION_TYPE == 2
    Approach approach(mico_names);
#elif SIMULATION_TYPE == 3
    SimulationWhole simulation(mico_names);
#else
    Simulation2_2 simulation(mico_names, mico_names2);
#endif
   
#if SIMULATION_TYPE == 2
    approach.run();
    //Simulation2 simulation(approach);
#endif
    
    //simulation.init();
    
    /*float t = simulation.getTime(), dt = 0.01;
    
    while (t < TMAX && !glfwWindowShouldClose(_Window))
    {
        glfwPollEvents();
        
        grapher->update(simulation.step());
        t += dt;
        
        glClear(GL_COLOR_BUFFER_BIT);
        
        glViewport(0, 0, V_WIDTH, V_HEIGHT);
        grapher->render0(shader);
        
        glViewport(0, V_HEIGHT, V_WIDTH, V_HEIGHT);
        grapher->render1(shader);
        
        glViewport(V_WIDTH, V_HEIGHT, V_WIDTH, V_HEIGHT);
        grapher->render2(shader);
        
        glViewport(V_WIDTH, 0, V_WIDTH, V_HEIGHT);
        grapher->render3(shader);
        
        glfwSwapBuffers(_Window);
    }*/
    
    /*glfwTerminate();
    
    GLenum errGL;
    while ((errGL = glGetError()) != GL_NO_ERROR)
    {
        cerr << "OpenGL error: " << errGL << endl;
    }*/
    
    return 0;
}

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)
{
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GL_TRUE);
    if(key == GLFW_KEY_Q && action == GLFW_PRESS)
    {
        
    }
}

void position_callback(GLFWwindow* window, double xpos, double ypos)
{
    cursorPositionX = (xpos - (float)WIDTH / 2.0)/(WIDTH / 2.0);
    cursorPositionY = ((float)HEIGHT / 2.0 - ypos) / (HEIGHT / 2.0);
}

void mouse_callback(GLFWwindow* window, int button, int action, int mods)
{
//        if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS &&
//           cursorPositionX < 0 && cursorPositionY < 0)
//            grapher->changeVariable(0, 1);
//        else if(button == GLFW_MOUSE_BUTTON_RIGHT && action == GLFW_PRESS &&
//                cursorPositionX < 0 && cursorPositionY < 0)
//            grapher->changeVariable(0, -1);
//        else if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS &&
//               cursorPositionX < 0 && cursorPositionY > 0)
//            grapher->changeVariable(1, 1);
//        else if(button == GLFW_MOUSE_BUTTON_RIGHT && action == GLFW_PRESS &&
//                cursorPositionX < 0 && cursorPositionY > 0)
//            grapher->changeVariable(1, -1);
//        else if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS &&
//                cursorPositionX > 0 && cursorPositionY > 0)
//            grapher->changeVariable(2, 1);
//        else if(button == GLFW_MOUSE_BUTTON_RIGHT && action == GLFW_PRESS &&
//                cursorPositionX > 0 && cursorPositionY > 0)
//            grapher->changeVariable(2, -1);
//        else if(button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS &&
//                cursorPositionX > 0 && cursorPositionY < 0)
//            grapher->changeVariable(3, 1);
//        else if(button == GLFW_MOUSE_BUTTON_RIGHT && action == GLFW_PRESS &&
//                cursorPositionX > 0 && cursorPositionY < 0)
//            grapher->changeVariable(3, -1);

}
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{

}

void init()
{
    if (!glfwInit())
    {
        printf("glfwInit() fail to initialize. \n");
        glfwTerminate();
        exit(-1);
    }
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
    
    _Window = glfwCreateWindow(WIDTH, HEIGHT, "MultiViewModelling", 0, 0);
    
    
    if (!_Window)
    {
        printf("Display window fail to create. \n");
        glfwTerminate();
        exit(-1);
    }
    
    glfwMakeContextCurrent(_Window);
    
#ifdef _LINUX
    glewExperimental = GL_TRUE;
    glewInit();
#endif
    
    glfwSetKeyCallback(_Window, key_callback);
    glfwSetCursorPosCallback(_Window, position_callback);
    glfwSetMouseButtonCallback(_Window, mouse_callback);
    glfwSetScrollCallback(_Window, scroll_callback);
    
#ifdef _LINUX
    glViewport(0, 0, WIDTH, HEIGHT);
#else
    glViewport(0, 0, WIDTH * 2, HEIGHT * 2);
#endif
    
    std::cout << glGetString(GL_VERSION) << std::endl;
}

